## <a href='https://school.programmers.co.kr/learn/courses/30/lessons/135808'>과일 장수</a>
```javascript
//재귀,런타임 에러
function solution(k, m, score) {
    score.sort((a, b) => b - a)
    const recursive = (k, m, score, profit = 0, boxes = 0) => {
        boxes = profit === 0 ? Math.floor(score.length / m) : boxes;

        const box = score.slice(0, m);
        const minPrice = Math.min(...box);
        const boxProfit = box.length === m ? box.length * minPrice : 0;

        profit += boxProfit;

        return boxes === 0 ? profit : () => recursive(k, m, score.slice(m), profit, boxes - 1);
    };

    const trampoline = (fn, result = fn()) => (typeof result === 'function' ? trampoline(result) : result);

    return trampoline(() => recursive(k, m, score));
}

//1. while을 사용하지만 while내부에서 최적화되지 않음(slice)
function solution(k, m, score) {
    score.sort((a, b) => b - a);

    let profit = 0;
    let boxes = Math.floor(score.length / m);

    while (boxes > 0) {
        const box = score.slice(0, m);
        const minPrice = Math.min(...box);
        const boxProfit = box.length === m ? box.length * minPrice : 0;

        profit += boxProfit;
        score = score.slice(m);
        boxes--;
    }

    return profit;
}

//2. while내부에서 slice가 반복되는 걸 줄임
function solution(k, m, score) {
    score.sort((a, b) => b - a);

    let profit = 0;
    let boxes = Math.floor(score.length / m);
    let index = 0;

    while (boxes > 0) {
        const box = score.slice(index, index + m);
        const minPrice = Math.min(...box);
        const boxProfit = box.length === m ? box.length * minPrice : 0;

        profit += boxProfit;
        index += m;
        boxes--;
    }

    return profit;
}


//재귀말고 반복...
const solution = (_, m, s) => s.sort().filter((_, i) => !((s.length - i) % m)).reduce((a, v) => a + v, 0) * m

/*좀 풀어서 정리, 
* 1. k - 사용되지 않음 언더바 처리
* 2. 
*/
const solution = (_, m, score) => 
    s.sort().filter((_, idx) => !((score.length - idx) % m)).reduce((acc, cur) => acc + cur, 0) * m

```
